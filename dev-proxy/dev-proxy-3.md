# 주요 기능 및 구현 상세
## CLI 도구 설계와 구현
### 대화형 환경 설정의 UX
진입장벽을 낮추기 위해 CLI 도구는 대화형 인터페이스로 설계했다.<br/>
개발자는 proxy config 명령어 한 번으로, 어떤 서비스가 어떤 환경(local/test 등)을 바라볼지 손쉽게 선택할 수 있다.<br/>
// TODO: 피드백을 통해 입력형에서 커서이동형으로 개선한 내용 추가<br/>
이 과정에서 실수로 잘못된 값을 입력하거나, 설정을 누락하는 일이 크게 줄었다.<br/>
### 명령어 체계와 사용 예시
CLI는 다음과 같은 명령어로 구성되어 있다.
- 환경 설정:
```proxy config```
- 프록시 서버 실행:
```proxy run```
- 현재 상태 확인:
```proxy status```

각 명령어는 직관적으로 설계되어, 별도의 문서 없이도 쉽게 사용할 수 있다.<br/>
### 내부 동작 흐름
사용자가 proxy config를 실행하면, CLI는 services.yaml을 읽어 서비스 목록을 파악한다.<br/>
각 서비스별로 환경(local/test 등)을 선택하도록 대화형 프롬프트를 제공한다.<br/>
선택 결과는 .dev-cli-env 파일에 저장된다.<br/>
이후 프록시 서버 실행 시, 이 파일을 참조해 실제 라우팅 및 환경 변수 생성에 활용한다.<br/>
## 프록시 서버의 라우팅 및 요청 중개
### FastAPI 기반 라우팅 구조
프록시 서버는 Python FastAPI로 구현되어 있다.<br/>
서비스별로 동적 라우팅을 지원하며, 새로운 서비스가 추가되어도 최소한의 코드 변경만으로 대응할 수 있다.<br/>
### 서비스별 동적/정적 라우팅 처리
대부분의 서비스는 `/서비스명/{path:path}` 패턴으로 동적 라우팅된다.<br/>
프론트엔드 등 정적 라우팅이 필요한 경우, 별도 리다이렉트 핸들러를 추가한다.<br/>
services.yaml의 메타데이터를 기반으로 라우팅 규칙을 자동 생성한다.<br/>
### 요청/응답 흐름과 주요 로직
클라이언트가 프록시 서버로 요청을 보낸다.<br/>
프록시 서버는 요청 경로를 분석해, 해당 서비스의 실제 엔드포인트를 결정한다.<br/>
요청을 실제 서비스로 중계(forward)하고, 응답을 받아 클라이언트에 전달한다.<br/>
요청/응답 과정에서 헤더, 쿼리스트링, 바디 등 모든 정보를 최대한 보존한다.<br/>
### 인증 토큰 처리
인증이 필요한 서비스의 경우, 프록시 서버가 토큰을 자동으로 삽입하거나, 기존 토큰을 유지해 전달한다.<br/>
인증 서버가 테스트 환경을 바라보도록 설정하면, 테스트 토큰을 받아 프론트엔드에 주입할 수 있다.<br/>
이를 통해 개발자는 인증/인가 로직을 별도로 신경쓰지 않고도 실제 환경과 유사하게 개발할 수 있다.<br/>
## 환경 변수 자동화 및 동기화
### .env.local 파일 생성 과정
프록시 서버는 .dev-cli-env와 AWS SSM 파라미터를 조합해, 각 서비스의 실제 엔드포인트를 결정한다.<br/>
이 정보를 바탕으로 .env.local 파일을 자동 생성한다.<br/>
개발자는 별도의 수작업 없이, 항상 최신 환경 변수를 사용할 수 있다.<br/>
### 서비스 추가/변경 시 동작 방식
services.yaml에 새로운 서비스가 추가되면, CLI와 프록시 서버가 이를 자동으로 인식한다.<br/>
환경 설정 및 .env.local 생성 과정에서 새 서비스가 반영된다.<br/>
서비스 환경 변경도 CLI를 통해 간편하게 처리할 수 있다.<br/>
### 실수 방지 및 일관성 확보 전략
환경 변수 파일을 직접 수정하지 않도록 가이드하고, 모든 변경은 CLI를 통해 이루어지게 한다.<br/>
.env.local은 git에 커밋되지 않으므로, 개인별 설정이 안전하게 분리된다.<br/>
중앙 관리되는 SSM 파라미터와 연동해, 환경별 엔드포인트가 일관되게 유지된다.<br/>